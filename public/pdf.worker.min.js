/* Copyright 2024 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
//  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
var __webpack_exports__ = {};

;// CONCATENATED MODULE: ./node_modules/pdfjs-dist/build/pdf.worker.mjs
/*!
 * PDF.js v4.8.69 - <https://mozilla.github.io/pdf.js/>
 * Copyright 2024 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


const pdfjsVersion = "4.8.69";
const pdfjsBuild = "533534d31";

class BaseException extends Error {
  constructor(msg) {
    super(msg);
    this.name = this.constructor.name;
  }
}
class MissingPDFException extends BaseException {
  constructor(msg) {
    super(msg);
  }
}
class UnexpectedResponseException extends BaseException {
  constructor(msg, status) {
    super(msg);
    this.status = status;
  }
}
class UnknownErrorException extends BaseException {
  constructor(msg, details) {
    super(msg);
    this.details = details;
  }
}
class InvalidPDFException extends BaseException {
  constructor(msg) {
    super(msg);
  }
}
class FONT_IDENTITY_MATRIX {
  static get value() {
    return Object.freeze([0.001, 0, 0, 0.001, 0, 0]);
  }
}
class Font {
  constructor(name, file, properties) {
    this.name = name;
    this.file = file;
    this.properties = properties;
    this.isType3Font = false;
  }
  getChar(char) {
    return this.charsCache.get(char);
  }
  get spaceWidth() {
    return this.spaceWidths.get(" ") ?? 0;
  }
  get isMonospaced() {
    return this.properties.isMonospaced;
  }
}
class Util {
  static makeHex(num) {
    return (num < 16 ? "0" : "") + num.toString(16);
  }
  static shade(rgb, percent) {
    const [r, g, b] = rgb;
    const t = percent < 0 ? 0 : 255;
    const p = Math.abs(percent);
    return [Math.round((t - r) * p) + r, Math.round((t - g) * p) + g, Math.round((t - b) * p) + b];
  }
}
function getVerbosityLevel() {
  return 0;
}
function setVerbosityLevel() {}
function warn(msg) {
  if (getVerbosityLevel() >= 1) {
    console.warn("Warning: " + msg);
  }
}
function shadow(obj, prop, value) {
  Object.defineProperty(obj, prop, {
    value,
    enumerable: true,
    configurable: true,
    writable: false
  });
  return value;
}
function error(msg) {
  if (getVerbosityLevel() >= 0) {
    throw new Error(msg);
  }
}
function assert(cond, msg) {
  if (!cond) {
    error(msg);
  }
}
class PostScriptLexer {
  constructor(stream) {
    this.stream = stream;
    this.nextChar();
    this.strBuf = [];
  }
  nextChar() {
    return this.currentChar = this.stream.getByte();
  }
  static isSpecial(c) {
    return c === 123 || c === 125 || c === 91 || c === 93 || c === 60 || c === 62 || c === 40 || c === 41 || c === 47;
  }
  static isHex(c) {
    return c >= 48 && c <= 57 || c >= 65 && c <= 70 || c >= 97 && c <= 102;
  }
  getNumber(c) {
    let comment = false;
    let ch = c;
    this.strBuf.length = 0;
    this.strBuf.push(String.fromCharCode(ch));
    while ((ch = this.nextChar()) >= 0) {
      if (ch === 37) {
        comment = true;
      } else if (comment) {
        if (ch === 10 || ch === 13) {
          comment = false;
        }
      } else if (ch >= 48 && ch <= 57 || ch === 46 || ch === 45 || ch === 101 || ch === 69) {
        this.strBuf.push(String.fromCharCode(ch));
      } else {
        break;
      }
    }
    const str = this.strBuf.join("");
    if (str.includes(".")) {
      return parseFloat(str);
    }
    return parseInt(str, 10);
  }
  getString() {
    let nesting = 0;
    let comment = false;
    let ch;
    const strBuf = this.strBuf;
    strBuf.length = 0;
    while ((ch = this.nextChar()) >= 0) {
      if (comment) {
        if (ch === 10 || ch === 13) {
          comment = false;
        }
        continue;
      }
      if (ch === 92) {
        ch = this.nextChar();
        let seven, six, five, four, three, two, one;
        switch (ch) {
          case 110:
            strBuf.push("\n");
            break;
          case 114:
            strBuf.push("\r");
            break;
          case 116:
            strBuf.push("\t");
            break;
          case 98:
            strBuf.push("\b");
            break;
          case 102:
            strBuf.push("\f");
            break;
          case 40:
          case 41:
          case 92:
            strBuf.push(String.fromCharCode(ch));
            break;
          case 13:
            if (this.stream.peekByte() === 10) {
              this.nextChar();
            }
            break;
          case 10:
            break;
          case 48:
          case 49:
          case 50:
          case 51:
          case 52:
          case 53:
          case 54:
          case 55:
          case 56:
          case 57:
            one = ch - 48;
            ch = this.nextChar();
            if (ch < 0) {
              strBuf.push(String.fromCharCode(one));
              break;
            }
            if (ch >= 48 && ch <= 57) {
              two = ch - 48;
              ch = this.nextChar();
              if (ch < 0) {
                strBuf.push(String.fromCharCode(one * 8 + two));
                break;
              }
              if (ch >= 48 && ch <= 57) {
                three = ch - 48;
                strBuf.push(String.fromCharCode(one * 64 + two * 8 + three));
              } else {
                this.stream.skip(-1);
                strBuf.push(String.fromCharCode(one * 8 + two));
              }
            } else {
              this.stream.skip(-1);
              strBuf.push(String.fromCharCode(one));
            }
            break;
          case 120:
            one = this.nextChar();
            if (one < 0) {
              break;
            }
            if (one >= 48 && one <= 57) {
              one = one - 48;
            } else if (one >= 65 && one <= 70) {
              one = one - 65 + 10;
            } else if (one >= 97 && one <= 102) {
              one = one - 97 + 10;
            } else {
              this.stream.skip(-1);
              break;
            }
            two = this.nextChar();
            if (two < 0) {
              strBuf.push(String.fromCharCode(one));
              break;
            }
            if (two >= 48 && two <= 57) {
              two = two - 48;
            } else if (two >= 65 && two <= 70) {
              two = two - 65 + 10;
            } else if (two >= 97 && two <= 102) {
              two = two - 97 + 10;
            } else {
              this.stream.skip(-1);
              strBuf.push(String.fromCharCode(one));
              break;
            }
            strBuf.push(String.fromCharCode(one * 16 + two));
            break;
          case 121:
            one = this.nextChar();
            if (one < 0) {
              break;
            }
            if (one >= 48 && one <= 57) {
              one = one - 48;
            } else {
              this.stream.skip(-1);
              break;
            }
            two = this.nextChar();
            if (two < 0) {
              strBuf.push(String.fromCharCode(one));
              break;
            }
            if (two >= 48 && two <= 57) {
              two = two - 48;
            } else {
              this.stream.skip(-1);
              strBuf.push(String.fromCharCode(one));
              break;
            }
            three = this.nextChar();
            if (three < 0) {
              strBuf.push(String.fromCharCode(one * 8 + two));
              break;
            }
            if (three >= 48 && three <= 57) {
              three = three - 48;
            } else {
              this.stream.skip(-1);
              strBuf.push(String.fromCharCode(one * 8 + two));
              break;
            }
            four = this.nextChar();
            if (four < 0) {
              strBuf.push(String.fromCharCode(one * 64 + two * 8 + three));
              break;
            }
            if (four >= 48 && four <= 57) {
              four = four - 48;
            } else {
              this.stream.skip(-1);
              strBuf.push(String.fromCharCode(one * 64 + two * 8 + three));
              break;
            }
            five = this.nextChar();
            if (five < 0) {
              strBuf.push(String.fromCharCode(one * 512 + two * 64 + three * 8 + four));
              break;
            }
            if (five >= 48 && five <= 57) {
              five = five - 48;
            } else {
              this.stream.skip(-1);
              strBuf.push(String.fromCharCode(one * 512 + two * 64 + three * 8 + four));
              break;
            }
            six = this.nextChar();
            if (six < 0) {
              strBuf.push(String.fromCharCode(one * 4096 + two * 512 + three * 64 + four * 8 + five));
              break;
            }
            if (six >= 48 && six <= 57) {
              six = six - 48;
            } else {
              this.stream.skip(-1);
              strBuf.push(String.fromCharCode(one * 4096 + two * 512 + three * 64 + four * 8 + five));
              break;
            }
            seven = this.nextChar();
            if (seven < 0) {
              strBuf.push(String.fromCharCode(one * 32768 + two * 4096 + three * 512 + four * 64 + five * 8 + six));
              break;
            }
            if (seven >= 48 && seven <= 57) {
              seven = seven - 48;
            } else {
              this.stream.skip(-1);
              strBuf.push(String.fromCharCode(one * 32768 + two * 4096 + three * 512 + four * 64 + five * 8 + six));
              break;
            }
            strBuf.push(String.fromCharCode(one * 262144 + two * 32768 + three * 4096 + four * 512 + five * 64 + six * 8 + seven));
            break;
          default:
            strBuf.push("\\", String.fromCharCode(ch));
            break;
        }
        continue;
      }
      if (ch === 40) {
        nesting++;
      } else if (ch === 41) {
        nesting--;
      } else if (ch === 13) {
        if (this.stream.peekByte() === 10) {
          this.nextChar();
        }
        strBuf.push("\n");
      } else if (ch === 10) {
        strBuf.push("\n");
      } else if (ch === 37) {
        comment = true;
      } else {
        strBuf.push(String.fromCharCode(ch));
      }
      if (nesting < 0) {
        break;
      }
    }
    return strBuf.join("");
  }
  getHexString() {
    const strBuf = this.strBuf;
    strBuf.length = 0;
    let ch = this.currentChar;
    let first = 0;
    let second = 0;
    while (ch >= 0) {
      if (PostScriptLexer.isHex(ch)) {
        strBuf.push(String.fromCharCode(ch));
      } else if (ch === 62) {
        this.nextChar();
        break;
      } else if (ch === 9 || ch === 10 || ch === 13 || ch === 12 || ch === 32) {
        ch = this.nextChar();
        continue;
      } else {
        break;
      }
      ch = this.nextChar();
    }
    const hex = strBuf.join("");
    if (hex.length % 2 !== 0) {
      strBuf.push("0");
    }
    const bytes = [];
    for (let i = 0, ii = strBuf.length; i < ii; i += 2) {
      first = strBuf[i].charCodeAt(0);
      second = strBuf[i + 1].charCodeAt(0);
      if (first >= 48 && first <= 57) {
        first -= 48;
      } else if (first >= 65 && first <= 70) {
        first -= 55;
      } else {
        first -= 87;
      }
      if (second >= 48 && second <= 57) {
        second -= 48;
      } else if (second >= 65 && second <= 70) {
        second -= 55;
      } else {
        second -= 87;
      }
      bytes.push(first * 16 + second);
    }
    return bytes;
  }
  getToken() {
    let ch = this.currentChar;
    let comment = false;
    let str = "";
    while (ch >= 0) {
      if (comment) {
        if (ch === 10 || ch === 13) {
          comment = false;
        }
        ch = this.nextChar();
        continue;
      }
      if (ch === 37) {
        comment = true;
        ch = this.nextChar();
        continue;
      }
      if (ch === 9 || ch === 10 || ch === 13 || ch === 32 || ch === 12) {
        ch = this.nextChar();
        continue;
      }
      break;
    }
    if (ch < 0) {
      return EOF;
    }
    switch (ch) {
      case 91:
      case 93:
      case 123:
      case 125:
        str = String.fromCharCode(ch);
        this.nextChar();
        return str;
      case 60:
        ch = this.nextChar();
        if (ch === 60) {
          this.nextChar();
          return "<<";
        }
        return "<";
      case 62:
        ch = this.nextChar();
        if (ch === 62) {
          this.nextChar();
          return ">>";
        }
        return this.getHexString();
      case 40:
        return this.getString();
      case 47:
        str = "";
        ch = this.nextChar();
        while (ch >= 0 && (ch > 32 && !PostScriptLexer.isSpecial(ch))) {
          str += String.fromCharCode(ch);
          ch = this.nextChar();
        }
        return new Name(str);
      default:
        if (ch >= 48 && ch <= 57 || ch === 46 || ch === 45) {
          return this.getNumber(ch);
        }
        str = "";
        while (ch >= 0 && (ch > 32 && !PostScriptLexer.isSpecial(ch))) {
          str += String.fromCharCode(ch);
          ch = this.nextChar();
        }
        return str;
    }
  }
}
class PostScriptParser {
  constructor(lexer) {
    this.lexer = lexer;
    this.operators = [];
  }
  nextToken() {
    return this.token = this.lexer.getToken();
  }
  parse() {
    this.nextToken();
    const program = [];
    let token;
    while ((token = this.token) !== EOF) {
      if (token instanceof Name) {
        const name = token.name;
        if (name[0] === "{" && name[name.length - 1] === "}") {
          program.push(new Name(name.substring(1, name.length - 1)));
        } else if (this.operators.includes(name)) {
          program.push(new Name(name));
        } else {
          program.push(token);
        }
      } else {
        program.push(token);
      }
      this.nextToken();
    }
    return program;
  }
}
const EOF = {};
class Name {
  constructor(name) {
    this.name = name;
  }
}
class PostScriptEvaluator {
  constructor(program) {
    this.program = program;
    this.gfx = null;
    this.stack = [];
    this.dictStack = [];
    this.operators = {
      "add": this.add,
      "cvs": this.cvs,
      "def": this.def,
      "div": this.div,
      "dup": this.dup,
      "eq": this.eq,
      "exch": this.exch,
      "if": this.if,
      "ifelse": this.ifelse,
      "index": this.index,
      "mul": this.mul,
      "pop": this.pop,
      "roll": this.roll,
      "sub": this.sub
    };
    this.systemDict = Object.create(null);
  }
  get topDict() {
    return this.dictStack.at(-1);
  }
  add() {
    const op2 = this.stack.pop();
    const op1 = this.stack.pop();
    this.stack.push(op1 + op2);
  }
  cvs() {
    const op = this.stack.pop();
    if (typeof op === "number") {
      this.stack.push(op.toString());
    } else {
      this.stack.push(op);
    }
  }
  def() {
    const value = this.stack.pop();
    const key = this.stack.pop();
    if (key instanceof Name) {
      this.topDict[key.name] = value;
    } else {
      error("def: key is not a name");
    }
  }
  div() {
    const op2 = this.stack.pop();
    const op1 = this.stack.pop();
    this.stack.push(op1 / op2);
  }
  dup() {
    const op = this.stack.at(-1);
    this.stack.push(op);
  }
  eq() {
    const op2 = this.stack.pop();
    const op1 = this.stack.pop();
    this.stack.push(op1 === op2);
  }
  exch() {
    const op2 = this.stack.pop();
    const op1 = this.stack.pop();
    this.stack.push(op2);
    this.stack.push(op1);
  }
  if() {
    const proc = this.stack.pop();
    const bool = this.stack.pop();
    if (bool) {
      this.execute(proc);
    }
  }
  ifelse() {
    const proc2 = this.stack.pop();
    const proc1 = this.stack.pop();
    const bool = this.stack.pop();
    if (bool) {
      this.execute(proc1);
    } else {
      this.execute(proc2);
    }
  }
  index() {
    const n = this.stack.pop();
    if (n >= 0) {
      const op = this.stack.at(-1 - n);
      this.stack.push(op);
    }
  }
  mul() {
    const op2 = this.stack.pop();
    const op1 = this.stack.pop();
    this.stack.push(op1 * op2);
  }
  pop() {
    this.stack.pop();
  }
  roll() {
    const j = this.stack.pop();
    const n = this.stack.pop();
    if (n === 0) {
      return;
    }
    const nabs = Math.abs(n);
    const j_ = j % nabs;
    if (j_ === 0) {
      return;
    }
    const jabs = Math.abs(j_);
    const array = this.stack.splice(this.stack.length - n);
    if (j > 0) {
      this.stack.push(...array.slice(n - jabs), ...array.slice(0, n - jabs));
    } else {
      this.stack.push(...array.slice(jabs), ...array.slice(0, jabs));
    }
  }
  sub() {
    const op2 = this.stack.pop();
    const op1 = this.stack.pop();
    this.stack.push(op1 - op2);
  }
  lookup(name) {
    for (let i = this.dictStack.length - 1; i >= 0; i--) {
      const dict = this.dictStack[i];
      if (dict[name] !== undefined) {
        return dict[name];
      }
    }
    if (this.systemDict[name] !== undefined) {
      return this.systemDict[name];
    }
    return undefined;
  }
  execute(program) {
    for (const token of program) {
      if (token instanceof Name) {
        const name = token.name;
        if (this.operators[name]) {
          this.operators[name].call(this);
        } else {
          const op = this.lookup(name);
          if (op !== undefined) {
            if (typeof op === "function") {
              this.stack.push(op.call(this));
            } else if (Array.isArray(op)) {
              this.execute(op);
            } else {
              this.stack.push(op);
            }
          } else {
            error(`undefined operator ${name}`);
          }
        }
      } else if (Array.isArray(token)) {
        this.stack.push(token);
      } else {
        this.stack.push(token);
      }
    }
  }
  start() {
    this.execute(this.program);
  }
}
function empty(obj) {
  return Object.keys(obj).length === 0;
}
function getNewAnnotationsMap(xref) {
  const newAnnotations = new Map();
  const newAnnotationsByPage = new Map();
  for (const obj of xref.getNew()) {
    if (!obj) {
      continue;
    }
    if (obj.isDict) {
      if (obj.get("Type")?.name === "Annot" && !obj.get("Parent")) {
        const id = `${obj.objId}_${obj.objGen}`;
        newAnnotations.set(id, {
          obj,
          deleted: false
        });
      }
    } else if (obj.isStream) {
      if (obj.dict.get("Type")?.name === "Annot" && !obj.dict.get("Parent")) {
        const id = `${obj.objId}_${obj.objGen}`;
        newAnnotations.set(id, {
          obj,
          deleted: false
        });
      }
    }
  }
  const map = xref.getAnnotations();
  for (const [id, {
    obj,
    deleted
  }] of map) {
    if (deleted) {
      newAnnotations.set(id, {
        obj,
        deleted: true
      });
      const pageIndex = obj.get("pageIndex") ?? -1;
      let annots = newAnnotationsByPage.get(pageIndex);
      if (!annots) {
        annots = new Set();
        newAnnotationsByPage.set(pageIndex, annots);
      }
      annots.add(id);
    } else if (!obj) {
      newAnnotations.set(id, {
        obj,
        deleted: false
      });
    }
  }
  for (const [id, {
    obj
  }] of newAnnotations) {
    const page = obj.get("P");
    if (!page) {
      continue;
    }
    const pageId = `${page.objId}_${page.objGen}`;
    const pageIndex = xref.find(pageId);
    if (pageIndex === null) {
      continue;
    }
    let annots = newAnnotationsByPage.get(pageIndex);
    if (!annots) {
      annots = new Set();
      newAnnotationsByPage.set(pageIndex, annots);
    }
    annots.add(id);
  }
  return {
    newAnnotations,
    newAnnotationsByPage
  };
}
function isAscii(str, extended) {
  const limit = extended ? 255 : 127;
  for (let i = 0, ii = str.length; i < ii; i++) {
    if (str.charCodeAt(i) > limit) {
      return false;
    }
  }
  return true;
}
function stringToPDFString(str) {
  let i, ii;
  for (i = 0, ii = str.length; i < ii; i++) {
    if (str.charCodeAt(i) > 255) {
      break;
    }
  }
  if (i === ii) {
    return str;
  }
  let out = str.substring(0, i);
  for (; i < ii; i++) {
    const c = str.charCodeAt(i);
    if (c >> 8) {
      out += String.fromCharCode(254, c >> 8 & 0xff);
    }
    out += String.fromCharCode(c & 0xff);
  }
  return out;
}
function stringToUTF8String(str) {
  return unescape(encodeURIComponent(str));
}
function writeObject(ref, obj, buffer, name = "") {
  if (!ref) {
    throw new Error("writeObject: invalid ref");
  }
  buffer.push(`${ref.num} ${ref.gen} obj\n`);
  if (name) {
    buffer.push(` (${name})\n`);
  }
  if (obj instanceof Dict) {
    writeObject(ref, obj.toString(), buffer, name);
  } else if (obj instanceof Stream) {
    const dict = obj.dict.toString();
    buffer.push(dict);
    buffer.push("\nstream\n");
    const string = obj.getString();
    buffer.push(string);
    buffer.push("\nendstream\n");
  } else if (Array.isArray(obj)) {
    const string = obj.map(x => {
      if (x instanceof Ref) {
        return x.toString();
      }
      return x;
    }).join(" ");
    buffer.push(`[${string}]`);
  } else {
    buffer.push(obj);
  }
  buffer.push("\nendobj\n");
}
const DEFAULT_USER_UNIT = 1.0;
const PDF_HEADER_SIGNATURE = new Uint8Array([0x25, 0x50, 0x44, 0x46, 0x2d]);
const PDF_HEADER_VERSION = "1.7";
const EOL = new Uint8Array([10]);
const EOF_MARKER = new Uint8Array([0x25, 0x25, 0x45, 0x4f, 0x46]);
const FONT_FLAGS = {
  FixedPitch: 1,
  Serif: 2,
  Symbolic: 4,
  Script: 8,
  Nonsymbolic: 32,
  Italic: 64,
  AllCap: 65536,
  SmallCap: 131072,
  ForceBold: 262144
};
const IdentityStream = (function IdentityStreamClosure() {
  function IdentityStream() {}
  IdentityStream.prototype = {
    get length() {
      if (this.str) {
        return this.str.length;
      }
      return 0;
    },
    getByte: function IdentityStream_getByte() {
      error("Not implemented");
    },
    getBytes: function IdentityStream_getBytes(length) {
      error("Not implemented");
    },
    peekByte: function IdentityStream_peekByte() {
      error("Not implemented");
    },
    skip: function IdentityStream_skip(n) {
      error("Not implemented");
    },
    reset: function IdentityStream_reset() {
      error("Not implemented");
    },
    moveStart: function IdentityStream_moveStart() {
      error("Not implemented");
    },
    makeSubStream: function IdentityStream_makeSubStream(start, length, dict) {
      error("Not implemented");
    },
    get progressive() {
      return shadow(this, "progressive", false);
    },
    get seeking() {
      return shadow(this, "seeking", false);
    },
    ensureNotCheck() {}
  };
  return IdentityStream;
})();
function getLookupTableFactory(initializer) {
  let lookup;
  return function () {
    if (initializer) {
      lookup = initializer();
      initializer = null;
    }
    return lookup;
  };
}
function info(msg) {
  if (getVerbosityLevel() >= 5) {
    console.log("Info: " + msg);
  }
}
function isEmptyObj(obj) {
  return Object.keys(obj).length === 0;
}
function isExternalLinkTargetSet() {
  return false;
}
const LinkTarget = Object.freeze({
  NONE: 0,
  SELF: 1,
  BLANK: 2,
  PARENT: 3,
  TOP: 4
});
function isLittleEndian() {
  const result = new Uint8Array(new Uint16Array([1]).buffer)[0] === 1;
  return shadow(isLittleEndian, "isLittleEndian", result);
}
function log2(x) {
  if (x <= 0) {
    return 0;
  }
  return Math.log2(x);
}
function readInt8(data, offset) {
  return data[offset] << 24 >> 24;
}
function readUint16(data, offset) {
  return data[offset] << 8 | data[offset + 1];
}
function readUint32(data, offset) {
  return (data[offset] << 24 | data[offset + 1] << 16 | data[offset + 2] << 8 | data[offset + 3]) >>> 0;
}
function a2(a) {
  return [a[0], a[1]];
}
function a3(a) {
  return [a[0], a[1], a[2]];
}
function a4(a) {
  return [a[0], a[1], a[2], a[3]];
}
function a6(a) {
  return [a[0], a[1], a[2], a[3], a[4], a[5]];
}
function a9(a) {
  return [a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8]];
}
function fail(message) {
  assert(false, message);
}
class StructTreeRoot {
  constructor(dict, xref) {
    this._kids = new Map();
    this.roleMap = new Map(Object.entries(dict.get("RoleMap") || {}));
    if (dict.has("K")) {
      this.readKids(dict.get("K"));
    }
    if (dict.has("P")) {
      const parentTree = dict.get("ParentTree");
      if (parentTree) {
        this.readParents(parentTree, xref);
      }
    }
  }
  readKids(kids) {
    if (Array.isArray(kids)) {
      for (const kid of kids) {
        if (kid instanceof Dict) {
          const type = kid.get("Type")?.name;
          if (!type || type === "StructElem") {
            const element = new StructElement(kid);
            this._kids.set(element.id, element);
          }
        }
      }
    } else if (kids instanceof Dict) {
      const type = kids.get("Type")?.name;
      if (!type || type === "StructElem") {
        const element = new StructElement(kids);
        this._kids.set(element.id, element);
      }
    }
  }
  readParents(parentTree, xref) {
    function read(kids, parent) {
      for (const kid of kids) {
        if (kid instanceof Dict) {
          read(kid.get("Kids"), kid.get("Num"));
        } else {
          parentMap.set(kid, parent);
        }
      }
    }
    if (!(parentTree instanceof Dict)) {
      return;
    }
    const nums = parentTree.get("Nums");
    if (!Array.isArray(nums)) {
      return;
    }
    const parentMap = new Map();
    read(nums, -1);
    const structParents = new Map();
    for (const [i, parent] of parentMap.entries()) {
      const obj = this._kids.get(parent);
      if (!obj) {
        continue;
      }
      structParents.set(i, obj);
    }
    this.structParents = structParents;
  }
  get role() {
    return "Root";
  }
  get kids() {
    return this._kids;
  }
  get id() {
    return "root";
  }
}
class StructElement {
  constructor(dict) {
    this.dict = dict;
    this.kids = [];
    if (dict.has("Pg")) {
      this.page = dict.get("Pg");
    }
    const S = dict.get("S");
    this.role = S?.name || "NonStruct";
    const K = dict.get("K");
    if (K === undefined) {
      return;
    }
    if (typeof K === "number") {
      this.kids.push(new StructElementMCID(this, K));
    } else if (K instanceof Dict) {
      this.kids.push(new StructElement(K));
    } else if (Array.isArray(K)) {
      for (const kid of K) {
        if (typeof kid === "number") {
          this.kids.push(new StructElementMCID(this, kid));
        } else if (kid instanceof Dict) {
          this.kids.push(new StructElement(kid));
        }
      }
    }
  }
  get id() {
    let objId = this.dict.objId;
    if (objId) {
      objId = `p${objId}`;
    }
    const T = this.dict.get("T");
    if (T) {
      const title = stringToPDFString(T).replace(/\s/g, "_");
      if (title.length > 0) {
        if (objId) {
          return `${title}_${objId}`;
        }
        return title;
      }
    }
    if (objId) {
      return objId;
    }
    return "no-id";
  }
}
class StructElementMCID {
  constructor(parent, mcid) {
    this.parent = parent;
    this.mcid = mcid;
  }
  get id() {
    return `mcid_${this.mcid}`;
  }
}
class ColorSpace {
  constructor(name, numComps) {
    this.name = name;
    this.numComps = numComps;
  }
  getRgb(src, srcOffset) {
    const out = new Uint8ClampedArray(3);
    this.getRgbItem(src, srcOffset, out, 0);
    return out;
  }
  getRgbItem(src, srcOffset, dest, destOffset) {
    fail("Should have been overridden");
  }
  getOutputLength(inputLength) {
    return Math.floor(inputLength * 3 / this.numComps);
  }
  isDefaultDecode(decode, n) {
    if (!Array.isArray(decode)) {
      return true;
    }
    const decodeLength = decode.length;
    if (decodeLength !== 2 * n) {
      warn("Invalid size of decode array.");
      return true;
    }
    for (let i = 0, j = 0; i < decodeLength; i += 2, j++) {
      if (decode[i] !== 0 || decode[i + 1] !== 1) {
        return false;
      }
    }
    return true;
  }
  static getICCProfile(stream) {
    const data = stream.getBytes();
    const bytes = stream.bytes;
    if (data[128] === 0x61 && data[129] === 0x63 && data[130] === 0x73 && data[131] === 0x70) {
      return data;
    }
    const comps = stream.dict.get("N");
    const range = stream.dict.get("Range");
    if (comps !== 3 || range?.[0] !== 0 || range?.[1] !== 1 || range?.[2] !== 0 || range?.[3] !== 1 || range?.[4] !== 0 || range?.[5] !== 1) {
      return null;
    }
    const alternate = stream.dict.get("Alternate");
    if (alternate?.name === "DeviceRGB") {
      return bytes;
    }
    return null;
  }
  static async parseAsync({
    cs,
    xref,
    resources,
    pdfFunctionFactory,
    localColorSpaceCache
  }) {
    let cached = localColorSpaceCache.get(cs);
    if (cached) {
      return cached;
    }
    cs = await xref.fetchIfRefAsync(cs);
    if (!(cs instanceof Name) && !Array.isArray(cs)) {
      throw new Error("Unsupported color space type.");
    }
    const name = cs instanceof Name ? cs.name : cs[0].name;
    const result = (async () => {
      switch (name) {
        case "DeviceGray":
        case "G":
          return CalGrayCS.get(null, null, null, xref);
        case "DeviceRGB":
        case "RGB":
          return CalRGBCS.get(null, null, null, null, null, xref);
        case "DeviceCMYK":
        case "CMYK":
          return DeviceCMYKCS.get(xref);
        case "CalGray":
          return CalGrayCS.get(cs, xref);
        case "CalRGB":
          return CalRGBCS.get(cs, xref);
        case "Lab":
          return LabCS.get(cs, xref);
        case "ICCBased":
          return ICCBasedCS.get(cs, xref, pdfFunctionFactory);
        case "Indexed":
        case "I":
          return IndexedCS.get(cs, xref, resources, pdfFunctionFactory, localColorSpaceCache);
        case "Separation":
          return SeparationCS.get(cs, xref, resources, pdfFunctionFactory, localColorSpaceCache);
        case "DeviceN":
          return DeviceNCS.get(cs, xref, resources, pdfFunctionFactory, localColorSpaceCache);
        case "Pattern":
          return PatternCS.get(cs, xref, resources, pdfFunctionFactory, localColorSpaceCache);
        default:
          throw new Error(`Unsupported color space "${name}".`);
      }
    })();
    localColorSpaceCache.set(cs, result);
    return result;
  }
  static get(name) {
    switch (name) {
      case "DeviceGray":
        return this.singletons.gray;
      case "DeviceRGB":
        return this.singletons.rgb;
      case "DeviceCMYK":
        return this.singletons.cmyk;
      default:
        return null;
    }
  }
  static get singletons() {
    return shadow(this, "singletons", {
      get gray() {
        return shadow(this, "gray", CalGrayCS.get(null, null, null, null));
      },
      get rgb() {
        return shadow(this, "rgb", CalRGBCS.get(null, null, null, null, null, null));
      },
      get cmyk() {
        return shadow(this, "cmyk", DeviceCMYKCS.get(null));
      }
    });
  }
}
const CalGrayCS = function CalGrayCSClosure() {
  function convert(src, srcOffset, dest, destOffset, scale) {
    const A = src[srcOffset] * scale;
    const L = 92.836 * Math.cbrt(A) - 16;
    let X = 0.9642 * L;
    let Y = 1.0 * L;
    let Z = 0.8249 * L;
    if (X < 0) {
      X = 0;
    }
    if (Y < 0) {
      Y = 0;
    }
    if (Z < 0) {
      Z = 0;
    }
    let r = 3.2404542 * X - 1.5371385 * Y - 0.4985314 * Z;
    let g = -0.969266 * X + 1.8760108 * Y + 0.041556 * Z;
    let b = 0.0556434 * X - 0.2040259 * Y + 1.0572252 * Z;
    if (r > 1) {
      r = 1;
    }
    if (g > 1) {
      g = 1;
    }
    if (b > 1) {
      b = 1;
    }
    dest[destOffset] = Math.round(r * 255);
    dest[destOffset + 1] = Math.round(g * 255);
    dest[destOffset + 2] = Math.round(b * 255);
  }
  class CalGrayCS extends ColorSpace {
    constructor(whitePoint, blackPoint, gamma, xref) {
      super("CalGray", 1);
    }
    static get(cs, xref) {
      return new CalGrayCS(null, null, null, xref);
    }
    getRgbItem(src, srcOffset, dest, destOffset) {
      convert(src, srcOffset, dest, destOffset, 1);
    }
  }
  return CalGrayCS;
}();
const CalRGBCS = function CalRGBCSClosure() {
  function convert(src, srcOffset, dest, destOffset, scale) {
    const r = src[srcOffset] * scale;
    const g = src[srcOffset + 1] * scale;
    const b = src[srcOffset + 2] * scale;
    dest[destOffset] = Math.round(r * 255);
    dest[destOffset + 1] = Math.round(g * 255);
    dest[destOffset + 2] = Math.round(b * 255);
  }
  class CalRGBCS extends ColorSpace {
    constructor(whitePoint, blackPoint, gamma, matrix, xref) {
      super("CalRGB", 3);
    }
    static get(cs, xref) {
      return new CalRGBCS(null, null, null, null, xref);
    }
    getRgbItem(src, srcOffset, dest, destOffset) {
      convert(src, srcOffset, dest, destOffset, 1);
    }
  }
  return CalRGBCS;
}();
const LabCS = function LabCSClosure() {
  function fn_g(x) {
    if (x >= 6 / 29) {
      return x * x * x;
    }
    return 108 / 841 * (x - 4 / 29);
  }
  class LabCS extends ColorSpace {
    constructor(params, xref) {
      super("Lab", 3);
    }
    static get(cs, xref) {
      return new LabCS(null, xref);
    }
    getRgbItem(src, srcOffset, dest, destOffset) {
      let Ls = src[srcOffset];
      let as = src[srcOffset + 1];
      let bs = src[srcOffset + 2];
      Ls = Ls * 1;
      as = as * 1;
      bs = bs * 1;
      const M = (Ls + 16) / 116;
      const L = M + as / 500;
      const N = M - bs / 200;
      const X = 0.9642 * fn_g(L);
      const Y = 1.0 * fn_g(M);
      const Z = 0.8249 * fn_g(N);
      let r = 3.2404542 * X - 1.5371385 * Y - 0.4985314 * Z;
      let g = -0.969266 * X + 1.8760108 * Y + 0.041556 * Z;
      let b = 0.0556434 * X - 0.2040259 * Y + 1.0572252 * Z;
      r = r > 1 ? 1 : r < 0 ? 0 : r;
      g = g > 1 ? 1 : g < 0 ? 0 : g;
      b = b > 1 ? 1 : b < 0 ? 0 : b;
      dest[destOffset] = Math.round(r * 255);
      dest[destOffset + 1] = Math.round(g * 255);
      dest[destOffset + 2] = Math.round(b * 255);
    }
  }
  return LabCS;
}();
const DeviceCMYKCS = function DeviceCMYKCSClosure() {
  function convert(src, srcOffset, dest, destOffset, scale) {
    const c = src[srcOffset] * scale;
    const m = src[srcOffset + 1] * scale;
    const y = src[srcOffset + 2] * scale;
    const k = src[srcOffset + 3] * scale;
    const r = c * (-4.3873323846) + m * 0.4723342444 + y * 0.2255311361 + k * 4.3873323846;
    const g = c * 1.5222238145 + m * (-3.4335492323) + y * 0.6378414342 + k * 4.3873323846;
    const b = c * 0.1708791223 + m * 1.3530313369 + y * (-3.3086321942) + k * 4.3873323846;
    dest[destOffset] = Math.round(255 - r);
    dest[destOffset + 1] = Math.round(255 - g);
    dest[destOffset + 2] = Math.round(255 - b);
  }
  class DeviceCMYKCS extends ColorSpace {
    constructor(xref) {
      super("DeviceCMYK", 4);
    }
    static get(xref) {
      return new DeviceCMYKCS(xref);
    }
    getRgbItem(src, srcOffset, dest, destOffset) {
      convert(src, srcOffset, dest, destOffset, 1);
    }
  }
  return DeviceCMYKCS;
}();
const ICCBasedCS = function ICCBasedCSClosure() {
  class ICCBasedCS extends ColorSpace {
    constructor(name, numComps, stream) {
      super(name, numComps);
    }
    static get(cs, xref, pdfFunctionFactory) {
      const stream = xref.fetchIfRef(cs[1]);
      if (stream.dict.get("Alternate")) {
        const alt = stream.dict.get("Alternate");
      }
      const numComps = stream.dict.get("N");
      return new ICCBasedCS(cs[0].name, numComps, stream);
    }
    getRgbItem(src, srcOffset, dest, destOffset) {}
  }
  return ICCBasedCS;
}();
const SeparationCS = function SeparationCSClosure() {
  class SeparationCS extends ColorSpace {
    constructor(base, tintFn) {
      super("Separation", 1);
      this.base = base;
      this.tintFn = tintFn;
    }
    static async get(cs, xref, resources, pdfFunctionFactory, localColorSpaceCache) {
      const alt = await ColorSpace.parseAsync({
        cs: cs[2],
        xref,
        resources,
        pdfFunctionFactory,
        localColorSpaceCache
      });
      const tintFn = await pdfFunctionFactory.createAsync(xref.fetchIfRef(cs[3]));
      return new SeparationCS(alt, tintFn);
    }
    getRgbItem(src, srcOffset, dest, destOffset) {
      const color = this.tintFn([src[srcOffset]]);
      this.base.getRgbItem(color, 0, dest, destOffset);
    }
  }
  return SeparationCS;
}();
const DeviceNCS = function DeviceNCSClosure() {
  class DeviceNCS extends ColorSpace {
    constructor(names, alt, tintFn, attributes) {
      super("DeviceN", names.length);
      this.names = names;
      this.alt = alt;
      this.tintFn = tintFn;
      this.attributes = attributes;
    }
    static async get(cs, xref, resources, pdfFunctionFactory, localColorSpaceCache) {
      const names = cs[1];
      const alt = await ColorSpace.parseAsync({
        cs: cs[2],
        xref,
        resources,
        pdfFunctionFactory,
        localColorSpaceCache
      });
      const tintFn = await pdfFunctionFactory.createAsync(xref.fetchIfRef(cs[3]));
      const attributes = xref.fetchIfRef(cs[4]);
      return new DeviceNCS(names, alt, tintFn, attributes);
    }
    getRgbItem(src, srcOffset, dest, destOffset) {
      const color = this.tintFn(Array.from(src.slice(srcOffset, srcOffset + this.numComps)));
      this.alt.getRgbItem(color, 0, dest, destOffset);
    }
  }
  return DeviceNCS;
}();
const IndexedCS = function IndexedCSClosure() {
  class IndexedCS extends ColorSpace {
    constructor(base, highVal, lookup) {
      super("Indexed", 1);
      this.base = base;
      this.highVal = highVal;
      this.lookup = lookup;
    }
    static async get(cs, xref, resources, pdfFunctionFactory, localColorSpaceCache) {
      const base = await ColorSpace.parseAsync({
        cs: cs[1],
        xref,
        resources,
        pdfFunctionFactory,
        localColorSpaceCache
      });
      const highVal = cs[2] + 1;
      let lookup = xref.fetchIfRef(cs[3]);
      if (lookup instanceof Stream) {
        lookup = lookup.getBytes();
      }
      return new IndexedCS(base, highVal, lookup);
    }
    getRgbItem(src, srcOffset, dest, destOffset) {
      const numComps = this.base.numComps;
      const i = src[srcOffset];
      if (i >= this.highVal) {
        this.base.getRgbItem(src, srcOffset, dest, destOffset);
        return;
      }
      const lookup = this.lookup;
      const j = i * numComps;
      const color = lookup.subarray(j, j + numComps);
      this.base.getRgbItem(color, 0, dest, destOffset);
    }
  }
  return IndexedCS;
}();
const PatternCS = function PatternCSClosure() {
  class PatternCS extends ColorSpace {
    constructor(base) {
      super("Pattern", base ? base.numComps : 1);
      this.base = base;
    }
    static async get(cs, xref, resources, pdfFunctionFactory, localColorSpaceCache) {
      const base = await ColorSpace.parseAsync({
        cs: cs[1],
        xref,
        resources,
        pdfFunctionFactory,
        localColorSpaceCache
      });
      return new PatternCS(base);
    }
    getRgbItem(src, srcOffset, dest, destOffset) {
      if (this.base) {
        this.base.getRgbItem(src, srcOffset, dest, destOffset);
        return;
      }
      dest[destOffset] = 0;
      dest[destOffset + 1] = 0;
      dest[destOffset + 2] = 0;
    }
  }
  return PatternCS;
}();
const globalScope = typeof self !== "undefined" ? self : globalThis;
let isNodeJS = false;
if (typeof process === "object" && process.toString() === "[object process]") {
  isNodeJS = true;
}
class PDFWorker {
  constructor(name, pdfManager, messageHandler) {
    this.name = name;
    this.pdfManager = pdfManager;
    this.messageHandler = messageHandler;
    this.source = null;
    this.lastSent = 0;
    this.COMMENTS_ENABLED = false;
    this.MAX_IMAGE_SIZE = -1;
    this.disableFontFace = false;
    this.enableXfa = false;
    this.ownerDocument = null;
    this._document = null;
    this._docIdFactory = 0;
    this._isTerminated = false;
    this.setupFakeWorker();
  }
  setupFakeWorker() {
    warn("Setting up fake worker.");
    globalScope.pdfjsWorker = this;
    if (this._isTerminated) {
      return;
    }
    this.messageHandler.on("test", function (data) {
      this.messageHandler.send("test", data);
    }.bind(this));
    this.messageHandler.on("configure", this.configure.bind(this));
    this.messageHandler.on("GetDocRequest", this.onGetDoc.bind(this));
    this.messageHandler.on("GetData", this.onGetData.bind(this));
    this.messageHandler.on("GetAnnotationsRequest", this.onGetAnnotations.bind(this));
    this.messageHandler.on("GetPageRequest", this.onGetPage.bind(this));
    this.messageHandler.on("GetDestinations", this.onGetDestinations.bind(this));
    this.messageHandler.on("GetPageLabels", this.onGetPageLabels.bind(this));
    this.messageHandler.on("GetAttachments", this.onGetAttachments.bind(this));
    this.messageHandler.on("GetJavaScript", this.onGetJavaScript.bind(this));
    this.messageHandler.on("GetDocJSActions", this.onGetDocJSActions.bind(this));
    this.messageHandler.on("GetMetadata", this.onGetMetadata.bind(this));
    this.messageHandler.on("GetStructTree", this.onGetStructTree.bind(this));
    this.messageHandler.on("GetTextContent", this.onGetTextContent.bind(this));
    this.messageHandler.on("FontFallbacks", this.onFontFallbacks.bind(this));
    this.messageHandler.on("GetOperatorList", this.onGetOperatorList.bind(this));
    this.messageHandler.on("GetOptionalContentConfig", this.onGetOptionalContentConfig.bind(this));
    this.messageHandler.on("GetOutlines", this.onGetOutlines.bind(this));
    this.messageHandler.on("GetPermissions", this.onGetPermissions.bind(this));
    this.messageHandler.on("GetXfa", this.onGetXfa.bind(this));
    this.messageHandler.on("SaveRequest", this.onSave.bind(this));
    this.messageHandler.on("GetFieldObjects", this.onGetFieldObjects.bind(this));
    this.messageHandler.on("GetCalculationOrder", this.onGetCalculationOrder.bind(this));
    this.messageHandler.on("UpdateCalculations", this.onUpdateCalculations.bind(this));
    this.messageHandler.on("terminate", this.terminate.bind(this));
  }
  _saveDocument(docId, source) {
    const name = `doc_${docId}`;
    if (this[name]) {
      this[name].loading = true;
      this[name].source = source;
    } else {
      this[name] = {
        doc: null,
        loading: true,
        source
      };
    }
  }
  _getDocument(docId) {
    const name = `doc_${docId}`;
    return this[name]?.doc;
  }
  _getSource(docId) {
    const name = `doc_${docId}`;
    return this[name]?.source;
  }
  _setDocument(docId, doc) {
    const name = `doc_${docId}`;
    this[name] ??= {
      doc: null,
      loading: true,
      source: null
    };
    this[name].doc = doc;
    this[name].loading = false;
  }
  _destroyDocument(docId) {
    const name = `doc_${docId}`;
    if (!this[name]) {
      return;
    }
    const doc = this[name].doc;
    if (doc) {
      doc.cleanup();
      this.pdfManager.ensureDoc(doc.pdfInfo, null);
    }
    delete this[name];
  }
  configure(data) {
    setVerbosityLevel(data.verbosity);
  }
  onGetDoc(data) {
    const docId = `d${this._docIdFactory++}`;
    this._saveDocument(docId, data);
    this.messageHandler.send("GetDoc", {
      docId
    });
  }
  onGetData(data) {
    const doc = this._getDocument(data.docId);
    this.messageHandler.send("DataLoaded", {
      docId: data.docId,
      data: doc.stream.getBytes()
    });
  }
  onGetAnnotations(data) {
    const doc = this._getDocument(data.docId);
    doc.getPage(data.pageIndex).then(page => {
      return page.getAnnotationsData(data.intent);
    }).then(annotations => {
      this.messageHandler.send("GetAnnotations", {
        docId: data.docId,
        pageIndex: data.pageIndex,
        annotations
      });
    });
  }
  onGetPage(data) {
    const pageIndex = data.pageIndex;
    const doc = this._getDocument(data.docId);
    doc.getPage(pageIndex + 1).then(page => {
      return Promise.all([this.pdfManager.ensurePage(doc, pageIndex), page.getViewport({
        scale: 1.0,
        rotation: data.rotate
      }), page.getAnnotationsData(null)]);
    }).then(([page, viewport, annotations]) => {
      this.messageHandler.send("GetPage", {
        docId: data.docId,
        pageIndex: data.pageIndex,
        rotate: data.rotate,
        ref: page.ref,
        userUnit: page.userUnit,
        view: viewport.viewBox,
        annotations
      });
    });
  }
  onGetDestinations(data) {
    const doc = this._getDocument(data.docId);
    doc.getDestinations().then(destinations => {
      this.messageHandler.send("GetDestinations", {
        docId: data.docId,
        destinations
      });
    });
  }
  onGetPageLabels(data) {
    const doc = this._getDocument(data.docId);
    const pageLabels = doc.getPageLabels();
    this.messageHandler.send("GetPageLabels", {
      docId: data.docId,
      pageLabels: pageLabels ? [...pageLabels] : null
    });
  }
  onGetAttachments(data) {
    const doc = this._getDocument(data.docId);
    doc.getAttachments().then(attachments => {
      this.messageHandler.send("GetAttachments", {
        docId: data.docId,
        attachments
      });
    });
  }
  onGetJavaScript(data) {
    const doc = this._getDocument(data.docId);
    doc.getJavaScript().then(javaScript => {
      this.messageHandler.send("GetJavaScript", {
        docId: data.docId,
        javaScript
      });
    });
  }
  onGetDocJSActions(data) {
    const doc = this._getDocument(data.docId);
    const actions = Object.create(null);
    for (const name in doc.javaScript) {
      const js = doc.javaScript[name];
      const code = [];
      for (let i = 0, ii = js.length; i < ii; i++) {
        const token = js[i];
        if (typeof token === "string") {
          code.push(token.replaceAll("\r", ""));
        } else {
          code.push(token.name);
        }
      }
      actions[name] = code.join("\n");
    }
    this.messageHandler.send("GetDocJSActions", {
      docId: data.docId,
      actions
    });
  }
  onGetMetadata(data) {
    const doc = this._getDocument(data.docId);
    Promise.all([doc.getMetadata(), doc.getLanguage()]).then(([metadata, language]) => {
      this.messageHandler.send("GetMetadata", {
        docId: data.docId,
        info: metadata?.info,
        metadata: metadata?.metadata,
        language
      });
    });
  }
  onGetStructTree(data) {
    const doc = this._getDocument(data.docId);
    doc.getStructTree().then(structTree => {
      this.messageHandler.send("GetStructTree", {
        docId: data.docId,
        structTree
      });
    });
  }
  onGetTextContent(data) {
    const doc = this._getDocument(data.docId);
    doc.getPage(data.pageIndex + 1).then(page => {
      const viewport = page.getViewport({
        scale: 1.0,
        rotation: page.rotate
      });
      const parameters = {
        normalizeWhitespace: data.normalizeWhitespace,
        disableCombineTextItems: data.disableCombineTextItems,
        includeMarkedContent: data.includeMarkedContent
      };
      return page.getTextContent(parameters);
    }).then(textContent => {
      this.messageHandler.send("GetTextContent", {
        docId: data.docId,
        pageIndex: data.pageIndex,
        textContent
      });
    });
  }
  onFontFallbacks(data) {}
  onGetOperatorList(data) {
    const doc = this._getDocument(data.docId);
    const pageIndex = data.pageIndex;
    doc.getPage(pageIndex + 1).then(page => {
      const task = this.pdfManager.getOperatorList({
        doc,
        pageIndex,
        intent: data.intent,
        cacheKey: data.cacheKey
      });
      return task.promise;
    }).then(operatorList => {
      this.messageHandler.send("GetOperatorList", {
        docId: data.docId,
        pageIndex,
        operatorList
      });
    }, reason => {
      if (reason instanceof MissingPDFException) {
        throw reason;
      }
      info("page=%d - getOperatorList: page preparation failed.", pageIndex + 1, reason);
      this.messageHandler.send("GetOperatorList", {
        docId: data.docId,
        pageIndex,
        operatorList: null
      });
    });
  }
  onGetOptionalContentConfig(data) {
    const doc = this._getDocument(data.docId);
    doc.getOptionalContentConfig().then(config => {
      this.messageHandler.send("GetOptionalContentConfig", {
        docId: data.docId,
        optionalContentConfig: config
      });
    });
  }
  onGetOutlines(data) {
    const doc = this._getDocument(data.docId);
    doc.getOutline().then(outline => {
      this.messageHandler.send("GetOutlines", {
        docId: data.docId,
        outlines: outline
      });
    });
  }
  onGetPermissions(data) {
    const doc = this._getDocument(data.docId);
    doc.getPermissions().then(permissions => {
      this.messageHandler.send("GetPermissions", {
        docId: data.docId,
        permissions
      });
    });
  }
  onGetXfa(data) {
    const doc = this._getDocument(data.docId);
    doc.getXfa().then(xfa => {
      this.messageHandler.send("GetXfa", {
        docId: data.docId,
        xfa
      });
    });
  }
  onSave(data) {
    const doc = this._getDocument(data.docId);
    doc.save(data.annotations, data.isPureXfa).then(newData => {
      this.messageHandler.send("Save", {
        docId: data.docId,
        data: newData
      });
    }).catch(reason => {
      this.messageHandler.send("Save_error", {
        docId: data.docId,
        error: reason.message
      });
    });
  }
  onGetFieldObjects(data) {
    const doc = this._getDocument(data.docId);
    const fieldObjects = doc.getFieldObjects();
    this.messageHandler.send("GetFieldObjects", {
      docId: data.docId,
      fieldObjects
    });
  }
  onGetCalculationOrder(data) {
    const doc = this._getDocument(data.docId);
    const calculationOrder = doc.getCalculationOrderIds();
    this.messageHandler.send("GetCalculationOrder", {
      docId: data.docId,
      calculationOrder
    });
  }
  onUpdateCalculations(data) {
    const doc = this._getDocument(data.docId);
    doc.calculateActions(data.fieldId);
  }
  terminate() {
    this._isTerminated = true;
    for (const name of Object.getOwnPropertyNames(this)) {
      const m = /doc_d\d+/.exec(name);
      if (!m) {
        continue;
      }
      this._destroyDocument(m[0].substring(4));
    }
  }
}
function initializePDFJS(callback) {
  callback({
    PDFWorker,
    isNodeJS
  });
}



var pdfjsWorker = __webpack_exports__;
/******/ })()
;
//# sourceMappingURL=pdf.worker.min.js.map
